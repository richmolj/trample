{
  "name": "Trample",
  "tagline": "Easily query elasticsearch given a client-side payload",
  "body": "# Implementation\r\n\r\nGiven a model set up with [searchkick](https://github.com/ankane/searchkick):\r\n\r\n```ruby\r\nclass Person < ActiveRecord::Base\r\n  searchkick\r\nend\r\n\r\nPerson.create!(name: 'Bart')\r\nPerson.create!(name: 'Homer')\r\n```\r\n\r\nCreate a corresponding Trample model:\r\n\r\n```ruby\r\n# app/models/people_search.rb\r\n\r\nclass PeopleSearch < Trample::Search\r\n  model Person\r\n\r\n  condition :name, single: true\r\n  condition :tags\r\n  condition :age, range: true\r\nend\r\n```\r\n\r\nYou can now query via **direct assignment**:\r\n\r\n```ruby\r\nsearch = PeopleSearch.new\r\nsearch.condition(:name).eq('Bart')\r\nsearch.query!\r\nsearch.results.first.name # => 'Bart'\r\n\r\n# You can also chain queries\r\nsearch\r\n  .condition(:name).eq('Bart')\r\n  .condition(:age).gt(8)\r\n  .condition(:tags).or(%w(funny stupid))\r\n  .sort('-age')\r\n  .paginate(number: 2, size: 10)\r\n```\r\n\r\nOr query by **constructor**:\r\n\r\n```ruby\r\nsearch = PeopleSearch.new(conditions: {name: 'Bart'})\r\nsearch.query!\r\nsearch.results.first.name # => 'Bart'\r\n```\r\n\r\nConstructor-style is particularly helpful for controllers accepting parameters. \r\n\r\n```ruby\r\ndef update\r\n  search = PeopleSearch.new(params[:people_search])\r\n  search.query!\r\n\r\n  render json: search, include: :results\r\nend\r\n```\r\n\r\nIf you're using Ember, [ember-cli-advanced-search](https://github.com/richmolj/ember-cli-advanced-search) makes generating Trample-compatible search requests easy. See [API Requests](http://richmolj.github.io/trample/#api-requests) for more examination of request/response.\r\n\r\n### Query Types\r\n\r\n* Equals\r\n  ```ruby\r\n    search.condition(:name).eq('Bart')\r\n    # or\r\n    PeopleSearch.new(conditions: {name: 'Bart'})\r\n  ```\r\n\r\n* And/Or\r\n  ```ruby\r\n    search.condition(:tags).or(%w(Bart Homer))\r\n    search.condition(:tags).and(%w(Bart Homer))\r\n    # or\r\n    PeopleSearch.new(conditions: {tags: {values: %w(Bart Homer), and: false}})\r\n    PeopleSearch.new(conditions: {tags: {values: %w(Bart Homer), and: true}})\r\n  ```\r\n\r\n* NOT\r\n  ```ruby\r\n    search.condition(:name).not('Bart')\r\n    # or\r\n    PeopleSearch.new(conditions: {name: {values: 'Bart', not: true}})\r\n  ```\r\n\r\n* Partial Match (any text)\r\n  ```ruby\r\n    # This field must be configured with searchkick's 'text_middle'\r\n    search.condition(:name).any_text('ar')\r\n    # or\r\n    PeopleSearch.new(conditions: {name: {values: 'ar', any_text: true}})\r\n  ```\r\n\r\n* Prefix Match\r\n  ```ruby\r\n    # This field must be configured with searchkick's 'text_start'\r\n    search.condition(:name).starts_with('Ba')\r\n    # or\r\n    PeopleSearch.new(conditions: {name: {values: 'Ba', prefix: true}})\r\n  ```\r\n\r\n* Keywords (multi-field)\r\n  ```ruby\r\n  class PeopleSearch < Trample::Search\r\n    model Person\r\n\r\n    condition :keywords, fields: [:name, :description]\r\n  end\r\n\r\n  PeopleSearch.new(conditions: {keywords: 'Bart'}) # Searches across both name and description fields\r\n  ```\r\n\r\n* Ranges\r\n  ```ruby\r\n    search.condition(:age).gt(8).lt(30)\r\n    search.condition(:age).gte(8).lte(30)\r\n    # or\r\n    PeopleSearch.new(conditions: {age: {from: 8, to: 30}})\r\n    PeopleSearch.new(conditions: {age: {from_eq: 8, to_eq: 30}})\r\n  ```\r\n\r\n* Pagination\r\n  ```ruby\r\n    search.paginate(number: 2, size: 10)\r\n    # or\r\n    PeopleSearch.new(metadata: {pagination: {current_page: 2, per_page: 10}})\r\n\r\n   # also\r\n   search.metadata.pagination.total\r\n   search.metadata.pagination.per_page\r\n   search.metadata.pagination.current_page\r\n  ```\r\n\r\n* Sorting\r\n  ```ruby\r\n    search.sort(:age) # asc\r\n    search.sort('-age') # desc\r\n    # or\r\n    PeopleSearch.new(metadata: {sort: [{age: 'asc'}]})\r\n    PeopleSearch.new(metadata: {sort: [{age: 'desc'}]})\r\n  ```\r\n\r\n* Profiling\r\n  ```ruby\r\n    search.query!\r\n    search.metadata.took # milliseconds\r\n  ```\r\n\r\n* Aggregations\r\n  * Return aggregations:\r\n    ```ruby\r\n      class PeopleSearch < Trample::Search\r\n        model Person\r\n        aggregation :tags\r\n      end\r\n\r\n      search.agg(:tags)\r\n      # or\r\n      PeopleSearch.new(aggregations: [{name: 'tags'}])\r\n\r\n      # then\r\n      search.query!\r\n      search.aggregations.first.buckets.inject({}) { |memo, e| memo.merge(e.key.downcase => e.count) }\r\n      # {'funny' => 2, 'smart' => 11}\r\n    ```\r\n\r\n  * Select aggregations (query with this value):\r\n    ```ruby\r\n      search.agg(tags: ['stupid']).query!\r\n      # or\r\n      PeopleSearch.new(aggregations: [{name: 'tags', buckets: [{key: 'stupid', selected: true}] }])\r\n    ```\r\n\r\n* Options on class definition\r\n  \r\n  Any of the constructor options can apply at the class definition as well:\r\n\r\n  ```ruby\r\n    class PeopleSearch < Trample::Search\r\n      condition :excluded_tags, not: true\r\n    end\r\n\r\n    PeopleSearch.new(conditions: {excluded_tags: %(foo bar)}) # where tags NOT IN 'foo' or 'bar'\r\n  ```\r\n\r\n# API Requests\r\n\r\nThe following examples show API usage following the [JSON API Specification](http://jsonapi.org). Trample itself doesn't care what your API looks like, these are just 'best practice' examples for smooth sailing.\r\n\r\n### Basic Search\r\n\r\n```ruby\r\n# PUT /people_search/:id\r\n\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: \"Bart\" }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```ruby\r\n# Response\r\n{\r\n  data: {\r\n    id: '1dc9c145-80cb-4d39-801d-1189afe1ec8c',\r\n    type: 'people-searches',\r\n    attributes: {\r\n      conditions: { name: \"Bart\" },\r\n      metadata: {\r\n        took: 8,\r\n        sort: [],\r\n        pagination: { total: 1, current_page: 1, per_page: 20 }\r\n      }\r\n    },\r\n    relationships: {\r\n      results: {\r\n        data: [\r\n          { id: 123, type: 'people' }\r\n        ]\r\n      }\r\n    },\r\n    included: [\r\n      { id: 123, type: 'people', attributes: { name: 'Bart' } }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### And/Or Queries\r\n\r\nHave your condition match the format `{ condition_name: { values: ['a', 'b'], and: true }`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: { values: ['Bart', 'Homer'], and: false } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### NOT Queries\r\n\r\nHave your condition match the format `{ condition_name: { values: 'string or array', not: true }`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: { values: 'Bart', not: true } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Prefix/Partial Matching\r\n\r\nFor prefix-matching, add `prefix: true` to the condition:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: \"Ba\", prefix: true }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nTo match text anywhere within a word, add `any_text: true` to the condition:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: \"ar\", any_text: true } # Matches 'Bart'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**NB**: Prefix/Partial matching will only work for fields that have been indexed to support it.\r\n\r\n### Keyword (multi-field) Queries\r\n\r\nSometimes you want to supply some text and search across multiple fields - the subject AND the body of an email, for instance. You can do this **server-side** or **client-side**:\r\n\r\nClient-side has the advantage of flexibility. But it requires the client to know more about how things are indexed:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { keywords: {values: 'foo', fields: [:subject, :body] }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nServer-side has the \"just works\" advantage. The domain experts writing code will manage the `keywords` fields themselves, clients get out-of-the-box functionality:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { keywords: 'foo' } # up to the backend what fields this searches\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Ranges\r\n\r\nUse `from/to` in your condition payload:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { age: { from: 7, to: 31 } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nOr use `from_eq/to_eq` for `>=/<=` functionality:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { age: { from_eq: 7, to_eq: 31 } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Pagination\r\n\r\nEdit `metadata.pagination.current_page` and/or `metadata.pagination.per_page`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      metadata: {\r\n        pagination: { current_page: 2, per_page: 50 }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Sorting\r\n\r\nEdit `metadata.sort` array. Valid values are `asc/desc`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      metadata: {\r\n        sort: [{name: 'desc'}]\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Aggregations (facets)\r\n\r\nSpecify the fields you want to aggregate on:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      aggregations: [{name: 'tags'}]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAggregations will be returned in the response as 'buckets':\r\n\r\n```ruby\r\n# Response\r\n{\r\n  data: {\r\n    id: '1dc9c145-80cb-4d39-801d-1189afe1ec8c',\r\n    type: 'people-searches',\r\n    attributes: {\r\n      aggregations: [\r\n        {\r\n          name: 'tags',\r\n          label: 'Tags', # defined server-side\r\n          order: 0, # defined server-side\r\n          buckets: [\r\n            { count: 17, key: 'funny', label: 'Funny', selected: false }, # From ES results\r\n            { count: 8, key: 'sad', label: 'Not Happy', selected: false }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nYou can change the `selected` flag of an aggregation to filter results matching that entry:\r\n\r\n```ruby\r\n# This will now only return results where 'tags' includes 'funny'\r\n{\r\n  data: {\r\n    attributes: {\r\n      aggregations: [{name: 'tags', buckets: [{key: 'funny', selected: true}] }]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**NB** Aggregations currently only supports `count` (facet) aggregations. In the future we will support `sum`s, `average`s, etc.\r\n\r\n### Autocompletes\r\n\r\nThere are two parts to autocompletes. First, the typeahead - the user types \"sim\" in an autocomplete, sees \"Simpson\" an \"Simmons\", and selects \"Simpson\". Second, execute an actual search query based on the \"Simpson\" selection.\r\n\r\nFor the typeahead, the request/response would look like:\r\n\r\n```ruby\r\nGET /autocompletes/last_names?filter=sim&per_page=5\r\n\r\n# Response\r\n{\r\n  results: [\r\n    { id: 1, key: 1, text: 'Simpson' },\r\n    { id: 2, key: 2, text: 'Simmons' }\r\n  ]\r\n}\r\n```\r\n\r\nIn this example, **id** is a unique identifier for the result (it will usually be the same as 'key', except for edge-cases where `key` is not unique). **key** is the actual value we'll query on - in this example we query on the ID of the associated record, **not** the string 'Simpson'. This way searches can be saved and replayed over time, giving the same results even if this person's last name changed from \"Simpson\" to \"Barnes-Simpson\". Finally, **text** is for display to the user.\r\n\r\nThis means you likely want to query on the `key`, after the user has selected an option:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { person_id: {values: [{key: 1}]} } # Note we're querying the person_id condition\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nFinally, there are **user queries**. This is when the user types into an autocomplete but actually wants to search the text \"sim\" instead of selecting an autocomplete result. It's up to the backend developers if this is supported or not for a given search. When user queries are enabled, you'd see an extra `user_query` key in the results:\r\n\r\n```ruby\r\nGET /autocompletes/last_names?filter=sim&per_page=5\r\n\r\n# Response\r\n{\r\n  results: [\r\n    { id: 'sim', key: 'sim', text: '\"sim\"', user_query: true},\r\n    { id: 1, key: 1, text: 'Simpson', user_query: false },\r\n    { id: 2, key: 2, text: 'Simmons', user_query: false }\r\n  ]\r\n}\r\n```\r\n\r\nIf the user selects this option, pass it along when querying - this makes sure we query a corresponding text field for this condition:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { person_id: {values: [{key: 'sim', user_query: true}]} } # Note we're querying the person_id condition\r\n    }\r\n  }\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}
{
  "name": "Trample",
  "tagline": "Easily query elasticsearch given a client-side payload",
  "body": "## API Requests\r\n\r\nThe following examples use the [JSON API Specification](http://jsonapi.org). YMMV.\r\n\r\n### Basic Search\r\n\r\n```ruby\r\n# PUT /people_search/:id\r\n\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: \"Bart\" }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```ruby\r\n# Response\r\n{\r\n  data: {\r\n    id: '1dc9c145-80cb-4d39-801d-1189afe1ec8c',\r\n    type: 'people-searches',\r\n    attributes: {\r\n      conditions: { name: \"Bart\" },\r\n      metadata: {\r\n        took: 8,\r\n        sort: [],\r\n        pagination: { total: 1, current_page: 1, per_page: 20 }\r\n      }\r\n    },\r\n    relationships: {\r\n      results: {\r\n        data: [\r\n          { id: 123, type: 'people' }\r\n        ]\r\n      }\r\n    },\r\n    included: [\r\n      { id: 123, type: 'people', attributes: { name: 'Bart' } }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### And/Or Queries\r\n\r\nHave your condition match the format `{ condition_name: { values: ['a', 'b'], and: true }`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: { values: ['Bart', 'Homer'], and: false } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### NOT Queries\r\n\r\nHave your condition match the format `{ condition_name: { values: 'string or array', not: true }`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: { values: 'Bart', not: true } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Prefix/Partial Matching\r\n\r\nFor prefix-matching, add `prefix: true` to the condition:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: \"Ba\", prefix: true }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nTo match text anywhere within a word, add `any_text: true` to the condition:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { name: \"ar\", any_text: true } // Matches 'Bart'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**NB**: Prefix/Partial matching will only work for fields that have been indexed to support it.\r\n\r\n### Keyword (multi-field) Queries\r\n\r\nSometimes you want to supply some text and search across multiple fields - the subject AND the body of an email, for instance. You can do this **server-side** or **client-side**:\r\n\r\nClient-side has the advantage of flexibility. But it requires the client to know more about how things are indexed:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { keywords: {values: 'foo', fields: [:subject, :body] }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nServer-side has the \"just works\" advantage. The domain experts writing code will manage the `keywords` fields themselves, clients get out-of-the-box functionality:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { keywords: 'foo' } # up to the backend what fields this searches\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Ranges\r\n\r\nUse `from/to` in your condition payload:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { age: { from: 7, to: 31 } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nOr use `from_eq/to_eq` for `>=/<=` functionality:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      conditions: { age: { from_eq: 7, to_eq: 31 } }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Pagination\r\n\r\nEdit `metadata.pagination.current_page` and/or `metadata.pagination.per_page`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      metadata: {\r\n        pagination: { current_page: 2, per_page: 50 }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Sorting\r\n\r\nEdit `metadata.sort` array. Valid values are `asc/desc`:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      metadata: {\r\n        sort: [{name: 'desc'}]\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Aggregations (facets)\r\n\r\nSpecify the fields you want to aggregate on:\r\n\r\n```ruby\r\n{\r\n  data: {\r\n    attributes: {\r\n      aggregations: [{name: 'tags'}]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAggregations will be returned in the response as 'buckets':\r\n\r\n```ruby\r\n# Response\r\n{\r\n  data: {\r\n    id: '1dc9c145-80cb-4d39-801d-1189afe1ec8c',\r\n    type: 'people-searches',\r\n    attributes: {\r\n      aggregations: [\r\n        {\r\n          name: 'tags',\r\n          label: 'Tags', # defined server-side\r\n          order: 0, # defined server-side\r\n          buckets: [\r\n            { count: 17, key: 'funny', label: 'Funny', selected: false } # From ES results\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nTo \"select\" an agg...\r\n\r\n**NB** Aggregations currently only supports `count` (facet) aggregations. In the future we will support `sum`s, `average`s, etc.\r\n\r\n### Autocompletes",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}
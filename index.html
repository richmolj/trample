<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Trample by richmolj</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Trample</h1>
        <p>Easily query elasticsearch given a client-side payload</p>

        <p class="view"><a href="https://github.com/richmolj/trample">View the Project on GitHub <small>richmolj/trample</small></a></p>


        <ul>
          <li><a href="https://github.com/richmolj/trample/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/richmolj/trample/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/richmolj/trample">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>
<a id="api-requests" class="anchor" href="#api-requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Requests</h2>

<p>The following examples use the <a href="http://jsonapi.org">JSON API Specification</a>. YMMV.</p>

<h3>
<a id="basic-search" class="anchor" href="#basic-search" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic Search</h3>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># PUT /people_search/:id</span>

{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>Bart<span class="pl-pds">"</span></span> }
    }
  }
}</pre></div>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># Response</span>
{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">id:</span> <span class="pl-s"><span class="pl-pds">'</span>1dc9c145-80cb-4d39-801d-1189afe1ec8c<span class="pl-pds">'</span></span>,
    <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people-searches<span class="pl-pds">'</span></span>,
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>Bart<span class="pl-pds">"</span></span> },
      <span class="pl-c1">metadata:</span> {
        <span class="pl-c1">took:</span> <span class="pl-c1">8</span>,
        <span class="pl-c1">sort:</span> [],
        <span class="pl-c1">pagination:</span> { <span class="pl-c1">total:</span> <span class="pl-c1">1</span>, <span class="pl-c1">current_page:</span> <span class="pl-c1">1</span>, <span class="pl-c1">per_page:</span> <span class="pl-c1">20</span> }
      }
    },
    <span class="pl-c1">relationships:</span> {
      <span class="pl-c1">results:</span> {
        <span class="pl-c1">data:</span> [
          { <span class="pl-c1">id:</span> <span class="pl-c1">123</span>, <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people<span class="pl-pds">'</span></span> }
        ]
      }
    },
    <span class="pl-c1">included:</span> [
      { <span class="pl-c1">id:</span> <span class="pl-c1">123</span>, <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people<span class="pl-pds">'</span></span>, <span class="pl-c1">attributes:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span> } }
    ]
  }
}</pre></div>

<h3>
<a id="andor-queries" class="anchor" href="#andor-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>And/Or Queries</h3>

<p>Have your condition match the format <code>{ condition_name: { values: ['a', 'b'], and: true }</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> { <span class="pl-c1">values:</span> [<span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Homer<span class="pl-pds">'</span></span>], <span class="pl-c1">and:</span> <span class="pl-c1">false</span> } }
    }
  }
}</pre></div>

<h3>
<a id="not-queries" class="anchor" href="#not-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NOT Queries</h3>

<p>Have your condition match the format <code>{ condition_name: { values: 'string or array', not: true }</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> { <span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>, <span class="pl-c1">not:</span> <span class="pl-c1">true</span> } }
    }
  }
}</pre></div>

<h3>
<a id="prefixpartial-matching" class="anchor" href="#prefixpartial-matching" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prefix/Partial Matching</h3>

<p>For prefix-matching, add <code>prefix: true</code> to the condition:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>Ba<span class="pl-pds">"</span></span>, <span class="pl-c1">prefix:</span> <span class="pl-c1">true</span> }
    }
  }
}</pre></div>

<p>To match text anywhere within a word, add <code>any_text: true</code> to the condition:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>ar<span class="pl-pds">"</span></span>, <span class="pl-c1">any_text:</span> <span class="pl-c1">true</span> } <span class="pl-k">//</span> <span class="pl-c1">Matches</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>
    }
  }
}</pre></div>

<p><strong>NB</strong>: Prefix/Partial matching will only work for fields that have been indexed to support it.</p>

<h3>
<a id="keyword-multi-field-queries" class="anchor" href="#keyword-multi-field-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Keyword (multi-field) Queries</h3>

<p>Sometimes you want to supply some text and search across multiple fields - the subject AND the body of an email, for instance. You can do this <strong>server-side</strong> or <strong>client-side</strong>:</p>

<p>Client-side has the advantage of flexibility. But it requires the client to know more about how things are indexed:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">keywords:</span> {<span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>, <span class="pl-c1">fields:</span> [<span class="pl-c1">:subject</span>, <span class="pl-c1">:body</span>] }
    }
  }
}</pre></div>

<p>Server-side has the "just works" advantage. The domain experts writing code will manage the <code>keywords</code> fields themselves, clients get out-of-the-box functionality:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">keywords:</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> } <span class="pl-c"># up to the backend what fields this searches</span>
    }
  }
}</pre></div>

<h3>
<a id="ranges" class="anchor" href="#ranges" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ranges</h3>

<p>Use <code>from/to</code> in your condition payload:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">age:</span> { <span class="pl-c1">from:</span> <span class="pl-c1">7</span>, <span class="pl-c1">to:</span> <span class="pl-c1">31</span> } }
    }
  }
}</pre></div>

<p>Or use <code>from_eq/to_eq</code> for <code>&gt;=/&lt;=</code> functionality:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">age:</span> { <span class="pl-c1">from_eq:</span> <span class="pl-c1">7</span>, <span class="pl-c1">to_eq:</span> <span class="pl-c1">31</span> } }
    }
  }
}</pre></div>

<h3>
<a id="pagination" class="anchor" href="#pagination" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pagination</h3>

<p>Edit <code>metadata.pagination.current_page</code> and/or <code>metadata.pagination.per_page</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">metadata:</span> {
        <span class="pl-c1">pagination:</span> { <span class="pl-c1">current_page:</span> <span class="pl-c1">2</span>, <span class="pl-c1">per_page:</span> <span class="pl-c1">50</span> }
      }
    }
  }
}</pre></div>

<h3>
<a id="sorting" class="anchor" href="#sorting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sorting</h3>

<p>Edit <code>metadata.sort</code> array. Valid values are <code>asc/desc</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">metadata:</span> {
        <span class="pl-c1">sort:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>desc<span class="pl-pds">'</span></span>}]
      }
    }
  }
}</pre></div>

<h3>
<a id="aggregations-facets" class="anchor" href="#aggregations-facets" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Aggregations (facets)</h3>

<p>Specify the fields you want to aggregate on:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">aggregations:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>}]
    }
  }
}</pre></div>

<p>Aggregations will be returned in the response as 'buckets':</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># Response</span>
{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">id:</span> <span class="pl-s"><span class="pl-pds">'</span>1dc9c145-80cb-4d39-801d-1189afe1ec8c<span class="pl-pds">'</span></span>,
    <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people-searches<span class="pl-pds">'</span></span>,
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">aggregations:</span> [
        {
          <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>,
          <span class="pl-c1">label:</span> <span class="pl-s"><span class="pl-pds">'</span>Tags<span class="pl-pds">'</span></span>, <span class="pl-c"># defined server-side</span>
          <span class="pl-c1">order:</span> <span class="pl-c1">0</span>, <span class="pl-c"># defined server-side</span>
          <span class="pl-c1">buckets:</span> [
            { <span class="pl-c1">count:</span> <span class="pl-c1">17</span>, <span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>funny<span class="pl-pds">'</span></span>, <span class="pl-c1">label:</span> <span class="pl-s"><span class="pl-pds">'</span>Funny<span class="pl-pds">'</span></span>, <span class="pl-c1">selected:</span> <span class="pl-c1">false</span> }, <span class="pl-c"># From ES results</span>
            { <span class="pl-c1">count:</span> <span class="pl-c1">8</span>, <span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>sad<span class="pl-pds">'</span></span>, <span class="pl-c1">label:</span> <span class="pl-s"><span class="pl-pds">'</span>Not Happy<span class="pl-pds">'</span></span>, <span class="pl-c1">selected:</span> <span class="pl-c1">false</span> }
          ]
        }
      ]
    }
  }
}</pre></div>

<p>You can change the <code>selected</code> flag of an aggregation to filter results matching that entry:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># This will now only return results where 'tags' includes 'funny'</span>
{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">aggregations:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>, <span class="pl-c1">buckets:</span> [{<span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>funny<span class="pl-pds">'</span></span>, <span class="pl-c1">selected:</span> <span class="pl-c1">true</span>}] }]
    }
  }
}</pre></div>

<p><strong>NB</strong> Aggregations currently only supports <code>count</code> (facet) aggregations. In the future we will support <code>sum</code>s, <code>average</code>s, etc.</p>

<h3>
<a id="autocompletes" class="anchor" href="#autocompletes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Autocompletes</h3>

<p>There are two parts to autocompletes. First, the typeahead - the user types "sim" in an autocomplete, sees "Simpson" an "Simmons", and selects "Simpson". Second, execute an actual search query based on the "Simpson" selection.</p>

<p>For the typeahead, the request/response would look like:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">GET</span> <span class="pl-k">/</span>autocompletes<span class="pl-k">/</span>last_names?filter<span class="pl-k">=</span>sim<span class="pl-k">&amp;</span>per_page<span class="pl-k">=</span><span class="pl-c1">5</span>

<span class="pl-c"># Response</span>
{
  <span class="pl-c1">results:</span> [
    { <span class="pl-c1">id:</span> <span class="pl-c1">1</span>, <span class="pl-c1">key:</span> <span class="pl-c1">1</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simpson<span class="pl-pds">'</span></span> },
    { <span class="pl-c1">id:</span> <span class="pl-c1">2</span>, <span class="pl-c1">key:</span> <span class="pl-c1">2</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simmons<span class="pl-pds">'</span></span> }
  ]
}</pre></div>

<p>In this example, <strong>id</strong> is a unique identifier for the result (it will usually be the same as 'key', except for edge-cases where <code>key</code> is not unique). <strong>key</strong> is the actual value we'll query on - in this example we query on the ID of the associated record, <strong>not</strong> the string 'Simpson'. This way searches can be saved and replayed over time, giving the same results even if this person's last name changed from "Simpson" to "Barnes-Simpson". Finally, <strong>text</strong> is for display to the user.</p>

<p>This means you likely want to query on the <code>key</code>, after the user has selected an option:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">person_id:</span> {<span class="pl-c1">values:</span> [{<span class="pl-c1">key:</span> <span class="pl-c1">1</span>}]} } <span class="pl-c"># Note we're querying the person_id condition</span>
    }
  }
}</pre></div>

<p>Finally, there are <strong>user queries</strong>. This is when the user types into an autocomplete but actually wants to search the text "sim" instead of selecting an autocomplete result. It's up to the backend developers if this is supported or not for a given search. When user queries are enabled, you'd see an extra <code>user_query</code> key in the results:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">GET</span> <span class="pl-k">/</span>autocompletes<span class="pl-k">/</span>last_names?filter<span class="pl-k">=</span>sim<span class="pl-k">&amp;</span>per_page<span class="pl-k">=</span><span class="pl-c1">5</span>

<span class="pl-c"># Response</span>
{
  <span class="pl-c1">results:</span> [
    { <span class="pl-c1">id:</span> <span class="pl-s"><span class="pl-pds">'</span>sim<span class="pl-pds">'</span></span>, <span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>sim<span class="pl-pds">'</span></span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>"sim"<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">true</span>},
    { <span class="pl-c1">id:</span> <span class="pl-c1">1</span>, <span class="pl-c1">key:</span> <span class="pl-c1">1</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simpson<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">false</span> },
    { <span class="pl-c1">id:</span> <span class="pl-c1">2</span>, <span class="pl-c1">key:</span> <span class="pl-c1">2</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simmons<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">false</span> }
  ]
}</pre></div>

<p>If the user selects this option, pass it along when querying - this makes sure we query a corresponding text field for this condition:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">person_id:</span> {<span class="pl-c1">values:</span> [{<span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>sim<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">true</span>}]} } <span class="pl-c"># Note we're querying the person_id condition</span>
    }
  }
}</pre></div>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/richmolj">richmolj</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>

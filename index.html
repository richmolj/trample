<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Trample by richmolj</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Trample</h1>
        <p>Easily query elasticsearch given a client-side payload</p>

        <p class="view"><a href="https://github.com/richmolj/trample">View the Project on GitHub <small>richmolj/trample</small></a></p>


        <ul>
          <li><a href="https://github.com/richmolj/trample/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/richmolj/trample/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/richmolj/trample">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="implementation" class="anchor" href="#implementation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementation</h1>

<p>Given a model set up with <a href="https://github.com/ankane/searchkick">searchkick</a>:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Person<span class="pl-e"> &lt; ActiveRecord::Base</span></span>
  searchkick
<span class="pl-k">end</span>

<span class="pl-c1">Person</span>.create!(<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>)
<span class="pl-c1">Person</span>.create!(<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Homer<span class="pl-pds">'</span></span>)</pre></div>

<p>Create a corresponding Trample model:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># app/models/people_search.rb</span>

<span class="pl-k">class</span> <span class="pl-en">PeopleSearch<span class="pl-e"> &lt; Trample::Search</span></span>
  model <span class="pl-c1">Person</span>

  condition <span class="pl-c1">:name</span>, <span class="pl-c1">single:</span> <span class="pl-c1">true</span>
  condition <span class="pl-c1">:tags</span>
  condition <span class="pl-c1">:age</span>, <span class="pl-c1">range:</span> <span class="pl-c1">true</span>
<span class="pl-k">end</span></pre></div>

<p>You can now query via <strong>direct assignment</strong>:</p>

<div class="highlight highlight-source-ruby"><pre>search <span class="pl-k">=</span> <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>
search.condition(<span class="pl-c1">:name</span>).eq(<span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>)
search.query!
search.results.first.name <span class="pl-c"># =&gt; 'Bart'</span>

<span class="pl-c"># You can also chain queries</span>
search
  .condition(<span class="pl-c1">:name</span>).eq(<span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>)
  .condition(<span class="pl-c1">:age</span>).gt(<span class="pl-c1">8</span>)
  .condition(<span class="pl-c1">:tags</span>).<span class="pl-k">or</span>(<span class="pl-s"><span class="pl-pds">%w(</span>funny stupid<span class="pl-pds">)</span></span>)
  .sort(<span class="pl-s"><span class="pl-pds">'</span>-age<span class="pl-pds">'</span></span>)
  .paginate(<span class="pl-c1">number:</span> <span class="pl-c1">2</span>, <span class="pl-c1">size:</span> <span class="pl-c1">10</span>)</pre></div>

<p>Or query by <strong>constructor</strong>:</p>

<div class="highlight highlight-source-ruby"><pre>search <span class="pl-k">=</span> <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>})
search.query!
search.results.first.name <span class="pl-c"># =&gt; 'Bart'</span></pre></div>

<p>Constructor-style is particularly helpful for controllers accepting parameters. </p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">def</span> <span class="pl-en">update</span>
  search <span class="pl-k">=</span> <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(params[<span class="pl-c1">:people_search</span>])
  search.query!

  render <span class="pl-c1">json:</span> search, <span class="pl-c1">include:</span> <span class="pl-c1">:results</span>
<span class="pl-k">end</span></pre></div>

<p>If you're using Ember, <a href="https://github.com/richmolj/ember-cli-advanced-search">ember-cli-advanced-search</a> makes generating Trample-compatible search requests easy. See <a href="http://richmolj.github.io/trample/#api-requests">API Requests</a> for more examination of request/response.</p>

<h3>
<a id="query-types" class="anchor" href="#query-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Query Types</h3>

<ul>
<li>
<p>Equals</p>

<div class="highlight highlight-source-ruby"><pre>  search.condition(<span class="pl-c1">:name</span>).eq(<span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>})</pre></div>
</li>
<li>
<p>And/Or</p>

<div class="highlight highlight-source-ruby"><pre>  search.condition(<span class="pl-c1">:tags</span>).<span class="pl-k">or</span>(<span class="pl-s"><span class="pl-pds">%w(</span>Bart Homer<span class="pl-pds">)</span></span>)
  search.condition(<span class="pl-c1">:tags</span>).<span class="pl-k">and</span>(<span class="pl-s"><span class="pl-pds">%w(</span>Bart Homer<span class="pl-pds">)</span></span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">tags:</span> {<span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">%w(</span>Bart Homer<span class="pl-pds">)</span></span>, <span class="pl-c1">and:</span> <span class="pl-c1">false</span>}})
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">tags:</span> {<span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">%w(</span>Bart Homer<span class="pl-pds">)</span></span>, <span class="pl-c1">and:</span> <span class="pl-c1">true</span>}})</pre></div>
</li>
<li>
<p>NOT</p>

<div class="highlight highlight-source-ruby"><pre>  search.condition(<span class="pl-c1">:name</span>).<span class="pl-k">not</span>(<span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">name:</span> {<span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>, <span class="pl-c1">not:</span> <span class="pl-c1">true</span>}})</pre></div>
</li>
<li>
<p>Partial Match (any text)</p>

<div class="highlight highlight-source-ruby"><pre>  <span class="pl-c"># This field must be configured with searchkick's 'text_middle'</span>
  search.condition(<span class="pl-c1">:name</span>).any_text(<span class="pl-s"><span class="pl-pds">'</span>ar<span class="pl-pds">'</span></span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">name:</span> {<span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">'</span>ar<span class="pl-pds">'</span></span>, <span class="pl-c1">any_text:</span> <span class="pl-c1">true</span>}})</pre></div>
</li>
<li>
<p>Prefix Match</p>

<div class="highlight highlight-source-ruby"><pre>  <span class="pl-c"># This field must be configured with searchkick's 'text_start'</span>
  search.condition(<span class="pl-c1">:name</span>).starts_with(<span class="pl-s"><span class="pl-pds">'</span>Ba<span class="pl-pds">'</span></span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">name:</span> {<span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">'</span>Ba<span class="pl-pds">'</span></span>, <span class="pl-c1">prefix:</span> <span class="pl-c1">true</span>}})</pre></div>
</li>
<li>
<p>Keywords (multi-field)</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">PeopleSearch<span class="pl-e"> &lt; Trample::Search</span></span>
  model <span class="pl-c1">Person</span>

  condition <span class="pl-c1">:keywords</span>, <span class="pl-c1">fields:</span> [<span class="pl-c1">:name</span>, <span class="pl-c1">:description</span>]
<span class="pl-k">end</span>

<span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">keywords:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>}) <span class="pl-c"># Searches across both name and description fields</span></pre></div>
</li>
<li>
<p>Ranges</p>

<div class="highlight highlight-source-ruby"><pre>  search.condition(<span class="pl-c1">:age</span>).gt(<span class="pl-c1">8</span>).lt(<span class="pl-c1">30</span>)
  search.condition(<span class="pl-c1">:age</span>).gte(<span class="pl-c1">8</span>).lte(<span class="pl-c1">30</span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">age:</span> {<span class="pl-c1">from:</span> <span class="pl-c1">8</span>, <span class="pl-c1">to:</span> <span class="pl-c1">30</span>}})
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">age:</span> {<span class="pl-c1">from_eq:</span> <span class="pl-c1">8</span>, <span class="pl-c1">to_eq:</span> <span class="pl-c1">30</span>}})</pre></div>
</li>
<li>
<p>Pagination</p>

<div class="highlight highlight-source-ruby"><pre>  search.paginate(<span class="pl-c1">number:</span> <span class="pl-c1">2</span>, <span class="pl-c1">size:</span> <span class="pl-c1">10</span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">metadata:</span> {<span class="pl-c1">pagination:</span> {<span class="pl-c1">current_page:</span> <span class="pl-c1">2</span>, <span class="pl-c1">per_page:</span> <span class="pl-c1">10</span>}})

<span class="pl-c"># also</span>
search.metadata.pagination.total
search.metadata.pagination.per_page
search.metadata.pagination.current_page</pre></div>
</li>
<li>
<p>Sorting</p>

<div class="highlight highlight-source-ruby"><pre>  search.sort(<span class="pl-c1">:age</span>) <span class="pl-c"># asc</span>
  search.sort(<span class="pl-s"><span class="pl-pds">'</span>-age<span class="pl-pds">'</span></span>) <span class="pl-c"># desc</span>
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">metadata:</span> {<span class="pl-c1">sort:</span> [{<span class="pl-c1">age:</span> <span class="pl-s"><span class="pl-pds">'</span>asc<span class="pl-pds">'</span></span>}]})
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">metadata:</span> {<span class="pl-c1">sort:</span> [{<span class="pl-c1">age:</span> <span class="pl-s"><span class="pl-pds">'</span>desc<span class="pl-pds">'</span></span>}]})</pre></div>
</li>
<li>
<p>Profiling</p>

<div class="highlight highlight-source-ruby"><pre>  search.query!
  search.metadata.took <span class="pl-c"># milliseconds</span></pre></div>
</li>
<li>
<p>Aggregations</p>

<ul>
<li>
<p>Return aggregations:</p>

<div class="highlight highlight-source-ruby"><pre>  <span class="pl-k">class</span> <span class="pl-en">PeopleSearch<span class="pl-e"> &lt; Trample::Search</span></span>
    model <span class="pl-c1">Person</span>
    aggregation <span class="pl-c1">:tags</span>
  <span class="pl-k">end</span>

  search.agg(<span class="pl-c1">:tags</span>)
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">aggregations:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>}])

  <span class="pl-c"># then</span>
  search.query!
  search.aggregations.first.buckets.inject({}) { |<span class="pl-smi">memo</span>, <span class="pl-smi">e</span>| memo.merge(e.key.downcase =&gt; e.count) }
  <span class="pl-c"># {'funny' =&gt; 2, 'smart' =&gt; 11}</span></pre></div>
</li>
<li><p>Select aggregations (query with this value):</p></li>
</ul>

<div class="highlight highlight-source-ruby"><pre>  search.agg(<span class="pl-c1">tags:</span> [<span class="pl-s"><span class="pl-pds">'</span>stupid<span class="pl-pds">'</span></span>]).query!
  <span class="pl-c"># or</span>
  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">aggregations:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>, <span class="pl-c1">buckets:</span> [{<span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>stupid<span class="pl-pds">'</span></span>, <span class="pl-c1">selected:</span> <span class="pl-c1">true</span>}] }])</pre></div>
</li>
<li>
<p>Options on class definition
Any of the constructor options can apply at the class definition as well:</p>

<div class="highlight highlight-source-ruby"><pre>  <span class="pl-k">class</span> <span class="pl-en">PeopleSearch<span class="pl-e"> &lt; Trample::Search</span></span>
    condition <span class="pl-c1">:excluded_tags</span>, <span class="pl-c1">not:</span> <span class="pl-c1">true</span>
  <span class="pl-k">end</span>

  <span class="pl-c1">PeopleSearch</span>.<span class="pl-k">new</span>(<span class="pl-c1">conditions:</span> {<span class="pl-c1">excluded_tags:</span> <span class="pl-s"><span class="pl-pds">%(</span>foo bar<span class="pl-pds">)</span></span>}) <span class="pl-c"># where tags NOT IN 'foo' or 'bar'</span></pre></div>
</li>
</ul>

<h1>
<a id="api-requests" class="anchor" href="#api-requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Requests</h1>

<p>The following examples show API usage following the <a href="http://jsonapi.org">JSON API Specification</a>. Trample itself doesn't care what your API looks like, these are just 'best practice' examples for smooth sailing.</p>

<h3>
<a id="basic-search" class="anchor" href="#basic-search" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic Search</h3>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># PUT /people_search/:id</span>

{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>Bart<span class="pl-pds">"</span></span> }
    }
  }
}</pre></div>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># Response</span>
{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">id:</span> <span class="pl-s"><span class="pl-pds">'</span>1dc9c145-80cb-4d39-801d-1189afe1ec8c<span class="pl-pds">'</span></span>,
    <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people-searches<span class="pl-pds">'</span></span>,
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>Bart<span class="pl-pds">"</span></span> },
      <span class="pl-c1">metadata:</span> {
        <span class="pl-c1">took:</span> <span class="pl-c1">8</span>,
        <span class="pl-c1">sort:</span> [],
        <span class="pl-c1">pagination:</span> { <span class="pl-c1">total:</span> <span class="pl-c1">1</span>, <span class="pl-c1">current_page:</span> <span class="pl-c1">1</span>, <span class="pl-c1">per_page:</span> <span class="pl-c1">20</span> }
      }
    },
    <span class="pl-c1">relationships:</span> {
      <span class="pl-c1">results:</span> {
        <span class="pl-c1">data:</span> [
          { <span class="pl-c1">id:</span> <span class="pl-c1">123</span>, <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people<span class="pl-pds">'</span></span> }
        ]
      }
    },
    <span class="pl-c1">included:</span> [
      { <span class="pl-c1">id:</span> <span class="pl-c1">123</span>, <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people<span class="pl-pds">'</span></span>, <span class="pl-c1">attributes:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span> } }
    ]
  }
}</pre></div>

<h3>
<a id="andor-queries" class="anchor" href="#andor-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>And/Or Queries</h3>

<p>Have your condition match the format <code>{ condition_name: { values: ['a', 'b'], and: true }</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> { <span class="pl-c1">values:</span> [<span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Homer<span class="pl-pds">'</span></span>], <span class="pl-c1">and:</span> <span class="pl-c1">false</span> } }
    }
  }
}</pre></div>

<h3>
<a id="not-queries" class="anchor" href="#not-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NOT Queries</h3>

<p>Have your condition match the format <code>{ condition_name: { values: 'string or array', not: true }</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> { <span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">'</span>Bart<span class="pl-pds">'</span></span>, <span class="pl-c1">not:</span> <span class="pl-c1">true</span> } }
    }
  }
}</pre></div>

<h3>
<a id="prefixpartial-matching" class="anchor" href="#prefixpartial-matching" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prefix/Partial Matching</h3>

<p>For prefix-matching, add <code>prefix: true</code> to the condition:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>Ba<span class="pl-pds">"</span></span>, <span class="pl-c1">prefix:</span> <span class="pl-c1">true</span> }
    }
  }
}</pre></div>

<p>To match text anywhere within a word, add <code>any_text: true</code> to the condition:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">"</span>ar<span class="pl-pds">"</span></span>, <span class="pl-c1">any_text:</span> <span class="pl-c1">true</span> } <span class="pl-c"># Matches 'Bart'</span>
    }
  }
}</pre></div>

<p><strong>NB</strong>: Prefix/Partial matching will only work for fields that have been indexed to support it.</p>

<h3>
<a id="keyword-multi-field-queries" class="anchor" href="#keyword-multi-field-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Keyword (multi-field) Queries</h3>

<p>Sometimes you want to supply some text and search across multiple fields - the subject AND the body of an email, for instance. You can do this <strong>server-side</strong> or <strong>client-side</strong>:</p>

<p>Client-side has the advantage of flexibility. But it requires the client to know more about how things are indexed:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">keywords:</span> {<span class="pl-c1">values:</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>, <span class="pl-c1">fields:</span> [<span class="pl-c1">:subject</span>, <span class="pl-c1">:body</span>] }
    }
  }
}</pre></div>

<p>Server-side has the "just works" advantage. The domain experts writing code will manage the <code>keywords</code> fields themselves, clients get out-of-the-box functionality:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">keywords:</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span> } <span class="pl-c"># up to the backend what fields this searches</span>
    }
  }
}</pre></div>

<h3>
<a id="ranges" class="anchor" href="#ranges" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ranges</h3>

<p>Use <code>from/to</code> in your condition payload:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">age:</span> { <span class="pl-c1">from:</span> <span class="pl-c1">7</span>, <span class="pl-c1">to:</span> <span class="pl-c1">31</span> } }
    }
  }
}</pre></div>

<p>Or use <code>from_eq/to_eq</code> for <code>&gt;=/&lt;=</code> functionality:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">age:</span> { <span class="pl-c1">from_eq:</span> <span class="pl-c1">7</span>, <span class="pl-c1">to_eq:</span> <span class="pl-c1">31</span> } }
    }
  }
}</pre></div>

<h3>
<a id="pagination" class="anchor" href="#pagination" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pagination</h3>

<p>Edit <code>metadata.pagination.current_page</code> and/or <code>metadata.pagination.per_page</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">metadata:</span> {
        <span class="pl-c1">pagination:</span> { <span class="pl-c1">current_page:</span> <span class="pl-c1">2</span>, <span class="pl-c1">per_page:</span> <span class="pl-c1">50</span> }
      }
    }
  }
}</pre></div>

<h3>
<a id="sorting" class="anchor" href="#sorting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sorting</h3>

<p>Edit <code>metadata.sort</code> array. Valid values are <code>asc/desc</code>:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">metadata:</span> {
        <span class="pl-c1">sort:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>desc<span class="pl-pds">'</span></span>}]
      }
    }
  }
}</pre></div>

<h3>
<a id="aggregations-facets" class="anchor" href="#aggregations-facets" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Aggregations (facets)</h3>

<p>Specify the fields you want to aggregate on:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">aggregations:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>}]
    }
  }
}</pre></div>

<p>Aggregations will be returned in the response as 'buckets':</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># Response</span>
{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">id:</span> <span class="pl-s"><span class="pl-pds">'</span>1dc9c145-80cb-4d39-801d-1189afe1ec8c<span class="pl-pds">'</span></span>,
    <span class="pl-c1">type:</span> <span class="pl-s"><span class="pl-pds">'</span>people-searches<span class="pl-pds">'</span></span>,
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">aggregations:</span> [
        {
          <span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>,
          <span class="pl-c1">label:</span> <span class="pl-s"><span class="pl-pds">'</span>Tags<span class="pl-pds">'</span></span>, <span class="pl-c"># defined server-side</span>
          <span class="pl-c1">order:</span> <span class="pl-c1">0</span>, <span class="pl-c"># defined server-side</span>
          <span class="pl-c1">buckets:</span> [
            { <span class="pl-c1">count:</span> <span class="pl-c1">17</span>, <span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>funny<span class="pl-pds">'</span></span>, <span class="pl-c1">label:</span> <span class="pl-s"><span class="pl-pds">'</span>Funny<span class="pl-pds">'</span></span>, <span class="pl-c1">selected:</span> <span class="pl-c1">false</span> }, <span class="pl-c"># From ES results</span>
            { <span class="pl-c1">count:</span> <span class="pl-c1">8</span>, <span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>sad<span class="pl-pds">'</span></span>, <span class="pl-c1">label:</span> <span class="pl-s"><span class="pl-pds">'</span>Not Happy<span class="pl-pds">'</span></span>, <span class="pl-c1">selected:</span> <span class="pl-c1">false</span> }
          ]
        }
      ]
    }
  }
}</pre></div>

<p>You can change the <code>selected</code> flag of an aggregation to filter results matching that entry:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># This will now only return results where 'tags' includes 'funny'</span>
{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">aggregations:</span> [{<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>tags<span class="pl-pds">'</span></span>, <span class="pl-c1">buckets:</span> [{<span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>funny<span class="pl-pds">'</span></span>, <span class="pl-c1">selected:</span> <span class="pl-c1">true</span>}] }]
    }
  }
}</pre></div>

<p><strong>NB</strong> Aggregations currently only supports <code>count</code> (facet) aggregations. In the future we will support <code>sum</code>s, <code>average</code>s, etc.</p>

<h3>
<a id="autocompletes" class="anchor" href="#autocompletes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Autocompletes</h3>

<p>There are two parts to autocompletes. First, the typeahead - the user types "sim" in an autocomplete, sees "Simpson" an "Simmons", and selects "Simpson". Second, execute an actual search query based on the "Simpson" selection.</p>

<p>For the typeahead, the request/response would look like:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">GET</span> <span class="pl-k">/</span>autocompletes<span class="pl-k">/</span>last_names?filter<span class="pl-k">=</span>sim<span class="pl-k">&amp;</span>per_page<span class="pl-k">=</span><span class="pl-c1">5</span>

<span class="pl-c"># Response</span>
{
  <span class="pl-c1">results:</span> [
    { <span class="pl-c1">id:</span> <span class="pl-c1">1</span>, <span class="pl-c1">key:</span> <span class="pl-c1">1</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simpson<span class="pl-pds">'</span></span> },
    { <span class="pl-c1">id:</span> <span class="pl-c1">2</span>, <span class="pl-c1">key:</span> <span class="pl-c1">2</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simmons<span class="pl-pds">'</span></span> }
  ]
}</pre></div>

<p>In this example, <strong>id</strong> is a unique identifier for the result (it will usually be the same as 'key', except for edge-cases where <code>key</code> is not unique). <strong>key</strong> is the actual value we'll query on - in this example we query on the ID of the associated record, <strong>not</strong> the string 'Simpson'. This way searches can be saved and replayed over time, giving the same results even if this person's last name changed from "Simpson" to "Barnes-Simpson". Finally, <strong>text</strong> is for display to the user.</p>

<p>This means you likely want to query on the <code>key</code>, after the user has selected an option:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">person_id:</span> {<span class="pl-c1">values:</span> [{<span class="pl-c1">key:</span> <span class="pl-c1">1</span>}]} } <span class="pl-c"># Note we're querying the person_id condition</span>
    }
  }
}</pre></div>

<p>Finally, there are <strong>user queries</strong>. This is when the user types into an autocomplete but actually wants to search the text "sim" instead of selecting an autocomplete result. It's up to the backend developers if this is supported or not for a given search. When user queries are enabled, you'd see an extra <code>user_query</code> key in the results:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">GET</span> <span class="pl-k">/</span>autocompletes<span class="pl-k">/</span>last_names?filter<span class="pl-k">=</span>sim<span class="pl-k">&amp;</span>per_page<span class="pl-k">=</span><span class="pl-c1">5</span>

<span class="pl-c"># Response</span>
{
  <span class="pl-c1">results:</span> [
    { <span class="pl-c1">id:</span> <span class="pl-s"><span class="pl-pds">'</span>sim<span class="pl-pds">'</span></span>, <span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>sim<span class="pl-pds">'</span></span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>"sim"<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">true</span>},
    { <span class="pl-c1">id:</span> <span class="pl-c1">1</span>, <span class="pl-c1">key:</span> <span class="pl-c1">1</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simpson<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">false</span> },
    { <span class="pl-c1">id:</span> <span class="pl-c1">2</span>, <span class="pl-c1">key:</span> <span class="pl-c1">2</span>, <span class="pl-c1">text:</span> <span class="pl-s"><span class="pl-pds">'</span>Simmons<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">false</span> }
  ]
}</pre></div>

<p>If the user selects this option, pass it along when querying - this makes sure we query a corresponding text field for this condition:</p>

<div class="highlight highlight-source-ruby"><pre>{
  <span class="pl-c1">data:</span> {
    <span class="pl-c1">attributes:</span> {
      <span class="pl-c1">conditions:</span> { <span class="pl-c1">person_id:</span> {<span class="pl-c1">values:</span> [{<span class="pl-c1">key:</span> <span class="pl-s"><span class="pl-pds">'</span>sim<span class="pl-pds">'</span></span>, <span class="pl-c1">user_query:</span> <span class="pl-c1">true</span>}]} } <span class="pl-c"># Note we're querying the person_id condition</span>
    }
  }
}</pre></div>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/richmolj">richmolj</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
